/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY LLnextgen. DO NOT EDIT */
#line 10 "grammar.g"

#include "problem.h"

#line 7 "grammar.c"
#define LLthisType struct LLthis
#define LLscnt (LLthis->LLscnt_)
#define LLtcnt (LLthis->LLtcnt_)
#define LLcsymb (LLthis->LLcsymb_)
#define LL_NTERMINALS 35
#define LL_NSETS 24
#define LL_SSETS 8
#define LLinset(LLx) (LLsets[LLx*LL_SSETS + (LLcsymb/8)] & (1<<(LLcsymb & 7)))
#define LL_SCANDONE(LLx) if (LLsymb != LLx) LLerror(LLx);
#include <string.h>
static const char LLsets[] = {
	'\x04', 	'\x00', 	'\x02', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x28', 	'\x08', 	'\x02', 	'\xB4', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x30', 	'\x00', 	'\x02', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\xC0', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x02', 	'\x00', 	'\x04', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x08', 	'\x00', 	'\x60', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x04', 	'\x00', 	'\x08', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x08', 	'\x00', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x08', 	'\x00', 	'\xB4', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\xFC', 	'\xB7', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\x00', 	'\xBF', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x80', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\x00', 	'\xB7', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x04', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\xF8', 	'\xFC', 	'\xB7', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x30', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x8E', 	'\x00', 	'\x6C', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\xFC', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x68', 	'\x00', 	'\xB7', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x20', 	'\x00', 	'\x03', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x48', 	'\x00', 	'\xB4', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\xB4', 	'\x07', 	'\x00', 	'\x00', 	'\x00', 
	0
};
static const int LLindex[] = { 0,
	   0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	   0,    1,    2,    3,    4,    5,    6,    7,
	   8,    9,   10,   11,   12,   13,   14,   15,
	  16,   17,   18,   19,   20,   21,   22,   23,
	  24,   25,   26,   27,   28,   29,   30,   31,
	  32,   33,   34};
static const char *LLsymbolTable[] = {
"<EOF>", 
"<EOF>", "<SOH>", "<STX>", "<ETX>", 
"<EOT>", "<ENQ>", "<ACK>", "<BEL>", 
"<BS>", "<TAB>", "<NL>", "<VT>", 
"<FF>", "<CR>", "<SO>", "<SI>", 
"<DLE>", "<DC1>", "<DC2>", "<DC3>", 
"<DC4>", "<NAK>", "<SYN>", "<ETB>", 
"<CAN>", "<EM>", "<SUB>", "<ESC>", 
"<FS>", "<GS>", "<RS>", "<US>", 
"<SP>", "'!'", "'\"'", "'#'", 
"'$'", "'%'", "'&'", "'\''", 
"'('", "')'", "'*'", "'+'", 
"','", "'-'", "'.'", "'/'", 
"'0'", "'1'", "'2'", "'3'", 
"'4'", "'5'", "'6'", "'7'", 
"'8'", "'9'", "':'", "';'", 
"'<'", "'='", "'>'", "'?'", 
"'@'", "'A'", "'B'", "'C'", 
"'D'", "'E'", "'F'", "'G'", 
"'H'", "'I'", "'J'", "'K'", 
"'L'", "'M'", "'N'", "'O'", 
"'P'", "'Q'", "'R'", "'S'", 
"'T'", "'U'", "'V'", "'W'", 
"'X'", "'Y'", "'Z'", "'['", 
"'\\'", "']'", "'^'", "'_'", 
"'`'", "'a'", "'b'", "'c'", 
"'d'", "'e'", "'f'", "'g'", 
"'h'", "'i'", "'j'", "'k'", 
"'l'", "'m'", "'n'", "'o'", 
"'p'", "'q'", "'r'", "'s'", 
"'t'", "'u'", "'v'", "'w'", 
"'x'", "'y'", "'z'", "'{'", 
"'|'", "'}'", "'~'", "<DEL>", 
"'\x80'", "'\x81'", "'\x82'", "'\x83'", 
"'\x84'", "'\x85'", "'\x86'", "'\x87'", 
"'\x88'", "'\x89'", "'\x8A'", "'\x8B'", 
"'\x8C'", "'\x8D'", "'\x8E'", "'\x8F'", 
"'\x90'", "'\x91'", "'\x92'", "'\x93'", 
"'\x94'", "'\x95'", "'\x96'", "'\x97'", 
"'\x98'", "'\x99'", "'\x9A'", "'\x9B'", 
"'\x9C'", "'\x9D'", "'\x9E'", "'\x9F'", 
"'\xA0'", "'\xA1'", "'\xA2'", "'\xA3'", 
"'\xA4'", "'\xA5'", "'\xA6'", "'\xA7'", 
"'\xA8'", "'\xA9'", "'\xAA'", "'\xAB'", 
"'\xAC'", "'\xAD'", "'\xAE'", "'\xAF'", 
"'\xB0'", "'\xB1'", "'\xB2'", "'\xB3'", 
"'\xB4'", "'\xB5'", "'\xB6'", "'\xB7'", 
"'\xB8'", "'\xB9'", "'\xBA'", "'\xBB'", 
"'\xBC'", "'\xBD'", "'\xBE'", "'\xBF'", 
"'\xC0'", "'\xC1'", "'\xC2'", "'\xC3'", 
"'\xC4'", "'\xC5'", "'\xC6'", "'\xC7'", 
"'\xC8'", "'\xC9'", "'\xCA'", "'\xCB'", 
"'\xCC'", "'\xCD'", "'\xCE'", "'\xCF'", 
"'\xD0'", "'\xD1'", "'\xD2'", "'\xD3'", 
"'\xD4'", "'\xD5'", "'\xD6'", "'\xD7'", 
"'\xD8'", "'\xD9'", "'\xDA'", "'\xDB'", 
"'\xDC'", "'\xDD'", "'\xDE'", "'\xDF'", 
"'\xE0'", "'\xE1'", "'\xE2'", "'\xE3'", 
"'\xE4'", "'\xE5'", "'\xE6'", "'\xE7'", 
"'\xE8'", "'\xE9'", "'\xEA'", "'\xEB'", 
"'\xEC'", "'\xED'", "'\xEE'", "'\xEF'", 
"'\xF0'", "'\xF1'", "'\xF2'", "'\xF3'", 
"'\xF4'", "'\xF5'", "'\xF6'", "'\xF7'", 
"'\xF8'", "'\xF9'", "'\xFA'", "'\xFB'", 
"'\xFC'", "'\xFD'", "'\xFE'", "'\xFF'", 
"<EOF>", "VARSTOK", "DOMAINSTOK", "CONSTRAINTSTOK", 
"SOLVETOK", "ALLTOK", "INTTYPE", "BOOLTYPE", 
"ARROWTOK", "BRACKOPEN", "BRACKCLOSE", "MINUSTOK", 
"PLUSTOK", "STARTOK", "POWTOK", "COMMATOK", 
"SEMITOK", "COLONTOK", "ISTOK", "SMALLERTOK", 
"GREATERTOK", "NEQTOK", "LEQTOK", "GEQTOK", 
"MODTOK", "DIVTOK", "PARENTOPEN", "PARENTCLOSE", 
"VARTOK", "DECTOK", "RANGETOK", "MAXTOK", 
"MINTOK", "ABSTOK", "ANYTOK"};
const char *LLgetSymbol(int LLtoken) {
	if (LLtoken < -1 || LLtoken > 290 /* == LL_MAXTOKNO */)
		return (char *) 0;
	return LLsymbolTable[LLtoken+1];
}
#include "grammar.h"
int yylex(struct LLthis *);
static int LLlexerWrapper(LLthisType *LLthis) {
	if (LLreissue == -2 /* LL_NEW_TOKEN */) {
		return yylex(LLthis);
	} else {
		int LLretval = LLreissue;
		LLreissue = -2 /* LL_NEW_TOKEN */;
		return LLretval;
	}
}
void LLmessage(struct LLthis *, int);
static void LLread(LLthisType *LLthis) { LLcsymb = LLindex[(LLsymb = LLlexerWrapper(LLthis)) + 1]; }
static int LLskip(LLthisType *LLthis) {
	int LL_i;
	if (LLcsymb >= 0) {
		if (LLtcnt[LLcsymb] != 0) return 0;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 0;
	}

	for (;;) {
		LLmessage(LLthis, 0 /* LL_DELETE */);
		while ((LLcsymb = LLindex[(LLsymb = LLlexerWrapper(LLthis)) + 1]) < 0) LLmessage(LLthis, 0 /* LL_DELETE */);
		if (LLtcnt[LLcsymb] != 0)
			return 1;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 1;
	}
}
static void LLerror(LLthisType *LLthis, int LLtoken) {
	if (LLtoken == 256 /* EOFILE */) {
		LLmessage(LLthis, -1 /* LL_MISSINGEOF */);
		while (LLindex[(LLsymb = LLlexerWrapper(LLthis)) + 1] != 0) /*NOTHING*/ ;
		return;
	}
	LLtcnt[LLindex[LLtoken + 1]]++;
	LLskip(LLthis);
	LLtcnt[LLindex[LLtoken + 1]]--;
	if (LLsymb != LLtoken) { LLreissue = LLsymb; LLmessage(LLthis, LLtoken); }
}
#define LLread() LLread(LLthis)
#define LLskip() LLskip(LLthis)
#define LLerror(LLx) LLerror(LLthis, LLx)
#line 13 "grammar.g"

	#include <stdio.h>
	#include <stdlib.h>
	#include <assert.h>
	#include "datatypes.h"
	#include "problem.h"
	#include "variable.h"
	#include "constraint.h"
	#include "solve.h"
	
	extern char * yytext;	
	extern int lineNr;
	void LLmessage(struct LLthis *llthis, int token) {
		printf("Parse error: line %d, unexpected token %s\n", lineNr, yytext);
		exit(EXIT_FAILURE);
	}

#line 227 "grammar.c"
static Problem LL0_problem(LLthisType *LLthis) ;
static void LL1_body(LLthisType *LLthis,
#line 34 "grammar.g"
Problem *p
#line 232 "grammar.c"
) ;
static VarList LL2_vars(LLthisType *LLthis) ;
static DataType LL3_datatype(LLthisType *LLthis) ;
static void LL4_domains(LLthisType *LLthis,
#line 71 "grammar.g"
Problem p
#line 239 "grammar.c"
) ;
static IntegerSet LL5_domain(LLthisType *LLthis) ;
static Tuple LL6_subdomain(LLthisType *LLthis) ;
static int LL7_integer(LLthisType *LLthis) ;
static int LL8_negposint(LLthisType *LLthis) ;
static ConstraintList LL9_constraints(LLthisType *LLthis) ;
static ConstraintList LL10_constraintlist(LLthisType *LLthis) ;
static SolveSpec LL11_solvespec(LLthisType *LLthis) ;
static int LL12_var(LLthisType *LLthis) ;
static FunctionCall LL13_functioncall(LLthisType *LLthis) ;
static VarList LL14_varlist(LLthisType *LLthis) ;
static void LL15_domainspec(LLthisType *LLthis,
#line 212 "grammar.g"
Problem p
#line 254 "grammar.c"
) ;
static Constraint LL16_constraint(LLthisType *LLthis) ;
static NumExp LL17_numExp(LLthisType *LLthis) ;
static Term LL18_term(LLthisType *LLthis) ;
static Factor LL19_factor(LLthisType *LLthis) ;
static Value LL20_value(LLthisType *LLthis) ;
static RelOperator LL21_relop(LLthisType *LLthis) ;
static TermOperator LL22_termop(LLthisType *LLthis) ;
static FactorOperator LL23_factorop(LLthisType *LLthis) ;
static Problem LL0_problem(LLthisType *LLthis) {
#line 30 "grammar.g"
Problem
#line 267 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL1_body(LLthis,
#line 31 "grammar.g"
&LLretval
#line 274 "grammar.c"
);
}
return LLretval;
}
static void LL1_body(LLthisType *LLthis,
#line 34 "grammar.g"
Problem *p
#line 282 "grammar.c"
) {
#line 129 "grammar.g"
ConstraintList
#line 286 "grammar.c"
c;
#line 154 "grammar.g"
SolveSpec
#line 290 "grammar.c"
s;
#line 49 "grammar.g"
VarList
#line 294 "grammar.c"
v;
memset(&c, 0, sizeof(c));
memset(&s, 0, sizeof(s));
memset(&v, 0, sizeof(v));
{
LLscnt[0]++;
LLscnt[1]++;
LLscnt[2]++;
v = LL2_vars(LLthis);
#line 35 "grammar.g"
{ 
		*p = emptyProblem(); 
		setVarsOfProblem(*p, v);
		
	}
#line 310 "grammar.c"
LLscnt[0]--;
LL4_domains(LLthis,
#line 40 "grammar.g"
*p
#line 315 "grammar.c"
);
LLscnt[1]--;
c = LL9_constraints(LLthis);
#line 41 "grammar.g"
{
		setConstraintsOfProblem(*p, c); 
	}
#line 323 "grammar.c"
LLscnt[2]--;
s = LL11_solvespec(LLthis);
#line 44 "grammar.g"
{ 
		(*p)->solvespec = s;
	}
#line 330 "grammar.c"
}
}
static VarList LL2_vars(LLthisType *LLthis) {
#line 49 "grammar.g"
VarList
#line 336 "grammar.c"
LLretval;
#line 207 "grammar.g"
VarList
#line 340 "grammar.c"
l;
#line 60 "grammar.g"
DataType
#line 344 "grammar.c"
t;
memset(&LLretval, 0, sizeof(LLretval));
memset(&l, 0, sizeof(l));
memset(&t, 0, sizeof(t));
{
#line 49 "grammar.g"
 LLretval = NULL; 
#line 352 "grammar.c"
LLtcnt[17]++;
LLtcnt[28]++;
LL_SCANDONE(257);/* VARSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 2:/* DOMAINSTOK */
break;
case 28:/* VARTOK */
LLtcnt[17]++;
LLscnt[3]++;
LLtcnt[16]++;
l = LL14_varlist(LLthis);
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
LLread();
t = LL3_datatype(LLthis);
#line 54 "grammar.g"
{ LLretval = addVars(LLretval, t, l);}
#line 379 "grammar.c"
LLread();
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
LLread();
continue;
}
LLtcnt[28]--;
break;
}
}
return LLretval;
}
static DataType LL3_datatype(LLthisType *LLthis) {
#line 60 "grammar.g"
DataType
#line 395 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 6:/* INTTYPE */
LLscnt[3]--;
LL_SCANDONE(262);/* INTTYPE */
#line 61 "grammar.g"
{ 
		LLretval = INTEGER;
	}
#line 412 "grammar.c"
break;
case 7:/* BOOLTYPE */
LLscnt[3]--;
LL_SCANDONE(263);/* BOOLTYPE */
#line 65 "grammar.g"
{ 
		LLretval = BOOLEAN;
	}
#line 421 "grammar.c"
break;
}
}
return LLretval;
}
static void LL4_domains(LLthisType *LLthis,
#line 71 "grammar.g"
Problem p
#line 430 "grammar.c"
) {
LLtcnt[17]++;
LLtcnt[28]++;
LL_SCANDONE(258);/* DOMAINSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 3:/* CONSTRAINTSTOK */
break;
case 28:/* VARTOK */
LLtcnt[16]++;
LL15_domainspec(LLthis,
#line 72 "grammar.g"
p
#line 452 "grammar.c"
);
LLread();
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
LLread();
continue;
}
LLtcnt[28]--;
break;
}
}
static IntegerSet LL5_domain(LLthisType *LLthis) {
#line 76 "grammar.g"
IntegerSet
#line 467 "grammar.c"
LLretval;
#line 106 "grammar.g"
Tuple
#line 471 "grammar.c"
sd;
memset(&LLretval, 0, sizeof(LLretval));
memset(&sd, 0, sizeof(sd));
{
#line 76 "grammar.g"
int min = 0;
#line 478 "grammar.c"
LLscnt[4]++;
LLscnt[5]++;
LLtcnt[15]++;
LLscnt[6]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 9:/* BRACKOPEN */
LLscnt[4]--;
LL_SCANDONE(265);/* BRACKOPEN */
break;
case 26:/* PARENTOPEN */
LLscnt[4]--;
LL_SCANDONE(282);/* PARENTOPEN */
#line 80 "grammar.g"
{
			min = 1;
		}
#line 500 "grammar.c"
break;
}
LLread();
LLscnt[5]--;
sd = LL6_subdomain(LLthis);
#line 84 "grammar.g"
{ 
		LLretval = emptyIntegerSet();
		sd.min += min; 
		addIntervalToSet(LLretval, sd.min, sd.max);
	}
#line 512 "grammar.c"
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 10:/* BRACKCLOSE */
case 27:/* PARENTCLOSE */
break;
case 15:/* COMMATOK */
LLscnt[5]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[5]--;
sd = LL6_subdomain(LLthis);
#line 91 "grammar.g"
{
			addIntervalToSet(LLretval, sd.min, sd.max); 
		}
#line 532 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 10:/* BRACKCLOSE */
LLscnt[6]--;
LL_SCANDONE(266);/* BRACKCLOSE */
break;
case 27:/* PARENTCLOSE */
LLscnt[6]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 98 "grammar.g"
{
			removeIntegerFromSet(LLretval, sd.max); 
		}
#line 555 "grammar.c"
break;
}
}
return LLretval;
}
static Tuple LL6_subdomain(LLthisType *LLthis) {
#line 106 "grammar.g"
Tuple
#line 564 "grammar.c"
LLretval;
#line 122 "grammar.g"
int
#line 568 "grammar.c"
min;
#line 122 "grammar.g"
int
#line 572 "grammar.c"
max;
memset(&LLretval, 0, sizeof(LLretval));
memset(&min, 0, sizeof(min));
memset(&max, 0, sizeof(max));
{
#line 106 "grammar.g"
int max;
#line 580 "grammar.c"
LLtcnt[30]++;
min = LL8_negposint(LLthis);
#line 107 "grammar.g"
{
		max = min; 
	}
#line 587 "grammar.c"
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[30]--;
break;
case 10:/* BRACKCLOSE */
case 15:/* COMMATOK */
case 27:/* PARENTCLOSE */
LLtcnt[30]--;
break;
case 30:/* RANGETOK */
LLtcnt[30]--;
LLscnt[7]++;
LL_SCANDONE(286);/* RANGETOK */
LLread();
LLscnt[7]--;
max = LL8_negposint(LLthis);
LLread();
}
#line 113 "grammar.g"
{LLretval = (Tuple){min, max};}
#line 611 "grammar.c"
}
return LLretval;
}
static int LL7_integer(LLthisType *LLthis) {
#line 116 "grammar.g"
int
#line 618 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_SCANDONE(285);/* DECTOK */
#line 117 "grammar.g"
{ 
		LLretval = atoi(yytext); 
	}
#line 627 "grammar.c"
}
return LLretval;
}
static int LL8_negposint(LLthisType *LLthis) {
#line 122 "grammar.g"
int
#line 634 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
#line 122 "grammar.g"
int mult = 1;
#line 640 "grammar.c"
LLtcnt[11]++;
LLtcnt[29]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[11]--;
break;
case 29:/* DECTOK */
LLtcnt[11]--;
break;
case 11:/* MINUSTOK */
LLtcnt[11]--;
LL_SCANDONE(267);/* MINUSTOK */
#line 123 "grammar.g"
{mult=-1;}
#line 657 "grammar.c"
LLread();
}
LLtcnt[29]--;
LL_SCANDONE(285);/* DECTOK */
#line 124 "grammar.g"
{ 
		LLretval = mult*atoi(yytext); 
	}
#line 666 "grammar.c"
}
return LLretval;
}
static ConstraintList LL9_constraints(LLthisType *LLthis) {
#line 129 "grammar.g"
ConstraintList
#line 673 "grammar.c"
LLretval;
#line 220 "grammar.g"
Constraint
#line 677 "grammar.c"
c;
memset(&LLretval, 0, sizeof(LLretval));
memset(&c, 0, sizeof(c));
{
LLtcnt[17]++;
LLscnt[8]++;
LL_SCANDONE(259);/* CONSTRAINTSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 131 "grammar.g"
{
		LLretval = NULL; 
	}
#line 692 "grammar.c"
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 4:/* SOLVETOK */
break;
case 5:/* ALLTOK */
case 11:/* MINUSTOK */
case 26:/* PARENTOPEN */
case 28:/* VARTOK */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
LLtcnt[16]++;
c = LL16_constraint(LLthis);
#line 135 "grammar.g"
{
			LLretval = addConstraint(LLretval, c); 
		}
#line 717 "grammar.c"
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
LLread();
continue;
}
LLscnt[8]--;
break;
}
}
return LLretval;
}
static ConstraintList LL10_constraintlist(LLthisType *LLthis) {
#line 142 "grammar.g"
ConstraintList
#line 732 "grammar.c"
LLretval;
#line 220 "grammar.g"
Constraint
#line 736 "grammar.c"
c;
memset(&LLretval, 0, sizeof(LLretval));
memset(&c, 0, sizeof(c));
{
LLtcnt[15]++;
c = LL16_constraint(LLthis);
#line 143 "grammar.g"
{ 
		LLretval = addConstraint(NULL, c); 
	}
#line 747 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 27:/* PARENTCLOSE */
break;
case 15:/* COMMATOK */
LLscnt[9]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[9]--;
c = LL16_constraint(LLthis);
#line 148 "grammar.g"
{ 
			LLretval = addConstraint(LLretval, c); 
		}
#line 766 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
}
return LLretval;
}
static SolveSpec LL11_solvespec(LLthisType *LLthis) {
#line 154 "grammar.g"
SolveSpec
#line 778 "grammar.c"
LLretval;
#line 116 "grammar.g"
int
#line 782 "grammar.c"
max;
memset(&LLretval, 0, sizeof(LLretval));
memset(&max, 0, sizeof(max));
{
LLtcnt[17]++;
LLscnt[10]++;
LL_SCANDONE(260);/* SOLVETOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
LLscnt[10]--;
LL_SCANDONE(261);/* ALLTOK */
#line 157 "grammar.g"
{ 
			LLretval.type = SOLVEALL;
		}
#line 807 "grammar.c"
break;
case 29:/* DECTOK */
LLscnt[10]--;
max = LL7_integer(LLthis);
#line 161 "grammar.g"
{ 
			LLretval.type = SOLVENR; 
			LLretval.max = max; 
		}
#line 817 "grammar.c"
break;
}
}
return LLretval;
}
static int LL12_var(LLthisType *LLthis) {
#line 168 "grammar.g"
int
#line 826 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LLtcnt[29]++;
LL_SCANDONE(284);/* VARTOK */
LLread();
LLtcnt[29]--;
LLretval = LL7_integer(LLthis);
}
return LLretval;
}
static FunctionCall LL13_functioncall(LLthisType *LLthis) {
#line 172 "grammar.g"
FunctionCall
#line 841 "grammar.c"
LLretval;
#line 231 "grammar.g"
NumExp
#line 845 "grammar.c"
arg1;
#line 231 "grammar.g"
NumExp
#line 849 "grammar.c"
arg2;
#line 142 "grammar.g"
ConstraintList
#line 853 "grammar.c"
l;
memset(&LLretval, 0, sizeof(LLretval));
memset(&arg1, 0, sizeof(arg1));
memset(&arg2, 0, sizeof(arg2));
memset(&l, 0, sizeof(l));
{
#line 172 "grammar.g"
 int argc; FunctionName name; void *argv; 
#line 862 "grammar.c"
LLscnt[11]++;
LL_0:
switch (LLcsymb) {
case 31:/* MAXTOK */
case 32:/* MINTOK */
LLscnt[11]--;
LLscnt[12]++;
LLtcnt[26]++;
LLscnt[13]++;
LLtcnt[15]++;
LLscnt[13]++;
LLtcnt[27]++;
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 31:/* MAXTOK */
LLscnt[12]--;
LL_SCANDONE(287);/* MAXTOK */
#line 174 "grammar.g"
{name = MAX;}
#line 886 "grammar.c"
break;
case 32:/* MINTOK */
LLscnt[12]--;
LL_SCANDONE(288);/* MINTOK */
#line 174 "grammar.g"
{name = MIN;}
#line 893 "grammar.c"
break;
}
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[13]--;
arg1 = LL17_numExp(LLthis);
LLtcnt[15]--;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[13]--;
arg2 = LL17_numExp(LLthis);
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 176 "grammar.g"
{	
			argc = 2; 
			NumExp *ar = safeMalloc(argc*sizeof(NumExp));
			ar[0] = arg1;
			ar[1] = arg2;
			argv = ar;
		}
#line 917 "grammar.c"
break;
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 33:/* ABSTOK */
LLscnt[11]--;
LLtcnt[26]++;
LLscnt[13]++;
LLtcnt[27]++;
LL_SCANDONE(289);/* ABSTOK */
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[13]--;
arg1 = LL17_numExp(LLthis);
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 187 "grammar.g"
{
			name = ABS; 
			argc = 1;
			NumExp *ar = safeMalloc(argc*sizeof(NumExp));
			ar[0] = arg1;
			argv = ar;
		}
#line 945 "grammar.c"
break;
case 5:/* ALLTOK */
case 34:/* ANYTOK */
LLscnt[11]--;
LLscnt[14]++;
LLtcnt[26]++;
LLscnt[15]++;
LLtcnt[27]++;
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
LLscnt[14]--;
LL_SCANDONE(261);/* ALLTOK */
#line 195 "grammar.g"
{name = ALL;}
#line 965 "grammar.c"
break;
case 34:/* ANYTOK */
LLscnt[14]--;
LL_SCANDONE(290);/* ANYTOK */
#line 195 "grammar.g"
{name = ANY;}
#line 972 "grammar.c"
break;
}
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[15]--;
l = LL10_constraintlist(LLthis);
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 197 "grammar.g"
{
			argc = 1;
			ConstraintList *p;
			p = safeMalloc(argc*sizeof(ConstraintList));
			p[0] = l;
			argv = p;
		}
#line 991 "grammar.c"
break;
}
#line 204 "grammar.g"
{ LLretval = newFunctionCall(name,argc,argv); }
#line 996 "grammar.c"
}
return LLretval;
}
static VarList LL14_varlist(LLthisType *LLthis) {
#line 207 "grammar.g"
VarList
#line 1003 "grammar.c"
LLretval;
#line 168 "grammar.g"
int
#line 1007 "grammar.c"
v;
#line 168 "grammar.g"
int
#line 1011 "grammar.c"
v2;
memset(&LLretval, 0, sizeof(LLretval));
memset(&v, 0, sizeof(v));
memset(&v2, 0, sizeof(v2));
{
LLtcnt[15]++;
v = LL12_var(LLthis);
#line 208 "grammar.g"
{LLretval = newVarList(v, NULL);}
#line 1021 "grammar.c"
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 8:/* ARROWTOK */
case 17:/* COLONTOK */
break;
case 15:/* COMMATOK */
LLscnt[16]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[16]--;
v2 = LL12_var(LLthis);
#line 209 "grammar.g"
{addVar(LLretval, v2);}
#line 1040 "grammar.c"
LLread();
continue;
}
LLtcnt[15]--;
break;
}
}
return LLretval;
}
static void LL15_domainspec(LLthisType *LLthis,
#line 212 "grammar.g"
Problem p
#line 1053 "grammar.c"
) {
#line 76 "grammar.g"
IntegerSet
#line 1057 "grammar.c"
d;
#line 207 "grammar.g"
VarList
#line 1061 "grammar.c"
vl;
memset(&d, 0, sizeof(d));
memset(&vl, 0, sizeof(vl));
{
LLtcnt[8]++;
LLscnt[17]++;
vl = LL14_varlist(LLthis);
LLtcnt[8]--;
LL_SCANDONE(264);/* ARROWTOK */
LLread();
LLscnt[17]--;
d = LL5_domain(LLthis);
#line 213 "grammar.g"
{
		setDomainsOfVars(p, vl, d); 
		freeVarList(vl); 
		freeIntegerSet(d);
	}
#line 1080 "grammar.c"
}
}
static Constraint LL16_constraint(LLthisType *LLthis) {
#line 220 "grammar.g"
Constraint
#line 1086 "grammar.c"
LLretval;
#line 231 "grammar.g"
NumExp
#line 1090 "grammar.c"
e1;
#line 231 "grammar.g"
NumExp
#line 1094 "grammar.c"
e2;
#line 260 "grammar.g"
RelOperator
#line 1098 "grammar.c"
op;
memset(&LLretval, 0, sizeof(LLretval));
memset(&e1, 0, sizeof(e1));
memset(&e2, 0, sizeof(e2));
memset(&op, 0, sizeof(op));
{
LLscnt[18]++;
e1 = LL17_numExp(LLthis);
#line 221 "grammar.g"
{LLretval = newValConstraint(e1);}
#line 1109 "grammar.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLscnt[18]--;
break;
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 27:/* PARENTCLOSE */
LLscnt[18]--;
break;
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
LLscnt[18]--;
LLscnt[18]++;
LLscnt[13]++;
op = LL21_relop(LLthis);
LLread();
LLscnt[13]--;
e2 = LL17_numExp(LLthis);
#line 224 "grammar.g"
{ 
			setOperatorOfConstraint(LLretval, op); 
			setSecondExp(LLretval, e2);
		}
#line 1139 "grammar.c"
}
}
return LLretval;
}
static NumExp LL17_numExp(LLthisType *LLthis) {
#line 231 "grammar.g"
NumExp
#line 1147 "grammar.c"
LLretval;
#line 236 "grammar.g"
Term
#line 1151 "grammar.c"
t1;
#line 236 "grammar.g"
Term
#line 1155 "grammar.c"
t2;
#line 274 "grammar.g"
TermOperator
#line 1159 "grammar.c"
op;
memset(&LLretval, 0, sizeof(LLretval));
memset(&t1, 0, sizeof(t1));
memset(&t2, 0, sizeof(t2));
memset(&op, 0, sizeof(op));
{
LLscnt[19]++;
t1 = LL18_term(LLthis);
#line 232 "grammar.g"
{LLretval = newNumExp(t1);}
#line 1170 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 27:/* PARENTCLOSE */
break;
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
LLscnt[19]++;
LLscnt[20]++;
op = LL22_termop(LLthis);
LLread();
LLscnt[20]--;
t2 = LL18_term(LLthis);
#line 233 "grammar.g"
{LLretval = addTerm(LLretval, op, t2);}
#line 1197 "grammar.c"
continue;
}
LLscnt[19]--;
break;
}
}
return LLretval;
}
static Term LL18_term(LLthisType *LLthis) {
#line 236 "grammar.g"
Term
#line 1209 "grammar.c"
LLretval;
#line 241 "grammar.g"
Factor
#line 1213 "grammar.c"
f;
#line 280 "grammar.g"
FactorOperator
#line 1217 "grammar.c"
o;
#line 241 "grammar.g"
Factor
#line 1221 "grammar.c"
f2;
memset(&LLretval, 0, sizeof(LLretval));
memset(&f, 0, sizeof(f));
memset(&o, 0, sizeof(o));
memset(&f2, 0, sizeof(f2));
{
LLscnt[22]++;
LLscnt[21]++;
f = LL19_factor(LLthis);
#line 237 "grammar.g"
{LLretval = newTerm(f);}
#line 1233 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 27:/* PARENTCLOSE */
break;
case 13:/* STARTOK */
case 24:/* MODTOK */
case 25:/* DIVTOK */
LLscnt[21]++;
LLscnt[22]++;
o = LL23_factorop(LLthis);
LLread();
f2 = LL19_factor(LLthis);
#line 238 "grammar.g"
{ LLretval = addFactor(LLretval, o, f2); }
#line 1262 "grammar.c"
continue;
}
LLscnt[21]--;
break;
}
}
return LLretval;
}
static Factor LL19_factor(LLthisType *LLthis) {
#line 241 "grammar.g"
Factor
#line 1274 "grammar.c"
LLretval;
#line 241 "grammar.g"
Factor
#line 1278 "grammar.c"
f;
#line 247 "grammar.g"
Value
#line 1282 "grammar.c"
v;
memset(&LLretval, 0, sizeof(LLretval));
memset(&f, 0, sizeof(f));
memset(&v, 0, sizeof(v));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
case 26:/* PARENTOPEN */
case 28:/* VARTOK */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
LLscnt[22]--;
v = LL20_value(LLthis);
#line 242 "grammar.g"
{ LLretval = newValueFactor(v); }
#line 1306 "grammar.c"
break;
case 11:/* MINUSTOK */
LLscnt[22]--;
LLscnt[22]++;
LL_SCANDONE(267);/* MINUSTOK */
LLread();
f = LL19_factor(LLthis);
#line 244 "grammar.g"
{ LLretval = newMinusFactor(f); }
#line 1316 "grammar.c"
break;
}
}
return LLretval;
}
static Value LL20_value(LLthisType *LLthis) {
#line 247 "grammar.g"
Value
#line 1325 "grammar.c"
LLretval;
#line 231 "grammar.g"
NumExp
#line 1329 "grammar.c"
exp;
#line 241 "grammar.g"
Factor
#line 1333 "grammar.c"
f;
#line 116 "grammar.g"
int
#line 1337 "grammar.c"
i;
#line 172 "grammar.g"
FunctionCall
#line 1341 "grammar.c"
fc;
#line 168 "grammar.g"
int
#line 1345 "grammar.c"
id;
memset(&LLretval, 0, sizeof(LLretval));
memset(&exp, 0, sizeof(exp));
memset(&f, 0, sizeof(f));
memset(&i, 0, sizeof(i));
memset(&fc, 0, sizeof(fc));
memset(&id, 0, sizeof(id));
{
LLscnt[23]++;
LLtcnt[14]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 29:/* DECTOK */
LLscnt[23]--;
i = LL7_integer(LLthis);
#line 249 "grammar.g"
{ LLretval = newIntVal(i); }
#line 1367 "grammar.c"
break;
case 28:/* VARTOK */
LLscnt[23]--;
id = LL12_var(LLthis);
#line 251 "grammar.g"
{ LLretval = newVarVal(id); }
#line 1374 "grammar.c"
break;
case 5:/* ALLTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
LLscnt[23]--;
fc = LL13_functioncall(LLthis);
#line 253 "grammar.g"
{ LLretval = newFuncVal(fc); }
#line 1385 "grammar.c"
break;
case 26:/* PARENTOPEN */
LLscnt[23]--;
LLscnt[13]++;
LLtcnt[27]++;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[13]--;
exp = LL17_numExp(LLthis);
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 255 "grammar.g"
{ LLretval = newNumExpVal(exp); }
#line 1399 "grammar.c"
break;
}
LLread();
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[14]--;
break;
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
case 13:/* STARTOK */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 24:/* MODTOK */
case 25:/* DIVTOK */
case 27:/* PARENTCLOSE */
LLtcnt[14]--;
break;
case 14:/* POWTOK */
LLtcnt[14]--;
LLscnt[22]++;
LL_SCANDONE(270);/* POWTOK */
LLread();
f = LL19_factor(LLthis);
#line 257 "grammar.g"
{LLretval->exponent = f;}
#line 1433 "grammar.c"
}
}
return LLretval;
}
static RelOperator LL21_relop(LLthisType *LLthis) {
#line 260 "grammar.g"
RelOperator
#line 1441 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 18:/* ISTOK */
LLscnt[18]--;
LL_SCANDONE(274);/* ISTOK */
#line 261 "grammar.g"
{ LLretval = IS; }
#line 1456 "grammar.c"
break;
case 19:/* SMALLERTOK */
LLscnt[18]--;
LL_SCANDONE(275);/* SMALLERTOK */
#line 263 "grammar.g"
{ LLretval = SMALLER; }
#line 1463 "grammar.c"
break;
case 20:/* GREATERTOK */
LLscnt[18]--;
LL_SCANDONE(276);/* GREATERTOK */
#line 265 "grammar.g"
{ LLretval = GREATER; }
#line 1470 "grammar.c"
break;
case 21:/* NEQTOK */
LLscnt[18]--;
LL_SCANDONE(277);/* NEQTOK */
#line 267 "grammar.g"
{ LLretval = NEQ; }
#line 1477 "grammar.c"
break;
case 22:/* LEQTOK */
LLscnt[18]--;
LL_SCANDONE(278);/* LEQTOK */
#line 269 "grammar.g"
{ LLretval = LEQ; }
#line 1484 "grammar.c"
break;
case 23:/* GEQTOK */
LLscnt[18]--;
LL_SCANDONE(279);/* GEQTOK */
#line 271 "grammar.g"
{ LLretval = GEQ; }
#line 1491 "grammar.c"
break;
}
}
return LLretval;
}
static TermOperator LL22_termop(LLthisType *LLthis) {
#line 274 "grammar.g"
TermOperator
#line 1500 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 11:/* MINUSTOK */
LLscnt[19]--;
LL_SCANDONE(267);/* MINUSTOK */
#line 275 "grammar.g"
{LLretval = MINUS;}
#line 1515 "grammar.c"
break;
case 12:/* PLUSTOK */
LLscnt[19]--;
LL_SCANDONE(268);/* PLUSTOK */
#line 277 "grammar.g"
{LLretval = PLUS;}
#line 1522 "grammar.c"
break;
}
}
return LLretval;
}
static FactorOperator LL23_factorop(LLthisType *LLthis) {
#line 280 "grammar.g"
FactorOperator
#line 1531 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 13:/* STARTOK */
LLscnt[21]--;
LL_SCANDONE(269);/* STARTOK */
#line 281 "grammar.g"
{ LLretval = MUL; }
#line 1546 "grammar.c"
break;
case 24:/* MODTOK */
LLscnt[21]--;
LL_SCANDONE(280);/* MODTOK */
#line 283 "grammar.g"
{ LLretval = MOD; }
#line 1553 "grammar.c"
break;
case 25:/* DIVTOK */
LLscnt[21]--;
LL_SCANDONE(281);/* DIVTOK */
#line 285 "grammar.g"
{ LLretval = DIV; }
#line 1560 "grammar.c"
break;
}
}
return LLretval;
}
#undef LLerror
#undef LLread
void parser(Problem LLuserData, Problem *LLretval) {
	LLthisType LLthis;
	memset(LLthis.LLscnt_, 0, LL_NSETS * sizeof(int));
	memset(LLthis.LLtcnt_, 0, LL_NTERMINALS * sizeof(int));
	LLthis.LLtcnt_[0]++;
	LLthis.LLdata_ = LLuserData;
	LLthis.LLsymb_ = 0;
	LLthis.LLreissue_ = -2 /* LL_NEW_TOKEN */;
	LLread(&LLthis);
	*LLretval = LL0_problem(&LLthis);
	LLread(&LLthis);
	if (LLthis.LLcsymb_ != 0) LLerror(&LLthis, 256 /* EOFILE*/);
}

