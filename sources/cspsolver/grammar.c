/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY LLnextgen. DO NOT EDIT */
#line 11 "grammar.g"

#include "vardb.h"
#include "rewrite.h"
#include <errno.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

#line 13 "grammar.c"
#define LL_NTERMINALS 46
#define LL_NSETS 25
#define LL_SSETS 8
#define LLinset(LLx) (LLsets[LLx*LL_SSETS + (LLcsymb/8)] & (1<<(LLcsymb & 7)))
#define LL_SCANDONE(LLx) if (LLsymb != LLx) LLerror(LLx);
static int LLscnt[LL_NSETS+1], LLtcnt[LL_NTERMINALS];
static int LLcsymb;
#include <string.h>
static const char LLsets[] = {
	'\x04', 	'\x00', 	'\x02', 	'\x10', 	'\x08', 	'\x00', 	'\x00', 	'\x00', 
	'\x28', 	'\x08', 	'\x02', 	'\xB4', 	'\x9F', 	'\x3F', 	'\x00', 	'\x00', 
	'\x30', 	'\x00', 	'\x02', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\xC0', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x10', 	'\x08', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x08', 	'\x00', 	'\xB4', 	'\x9F', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\xFF', 	'\x01', 	'\xF7', 	'\x9F', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\xFE', 	'\x00', 	'\xF7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\xFD', 	'\xB7', 	'\x9F', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\x00', 	'\xF7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\x00', 	'\xB7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\xFC', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x68', 	'\x00', 	'\xB7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x00', 	'\x20', 	'\x00', 	'\x03', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x48', 	'\x00', 	'\xB4', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\xB4', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\x78', 	'\xFC', 	'\xB7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x20', 	'\xF8', 	'\xFC', 	'\xBF', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x80', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\x00', 	'\x00', 	'\x00', 	'\x04', 	'\x00', 	'\x00', 	'\x00', 
	'\x20', 	'\xF8', 	'\xFC', 	'\xB7', 	'\x97', 	'\x3F', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x90', 	'\x3F', 	'\x00', 	'\x00', 
	'\x00', 	'\x02', 	'\x00', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	0
};
static const int LLindex[] = { 0,
	   0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	   0,    1,    2,    3,    4,    5,    6,    7,
	   8,    9,   10,   11,   12,   13,   14,   15,
	  16,   17,   18,   19,   20,   21,   22,   23,
	  24,   25,   26,   27,   28,   29,   30,   31,
	  32,   33,   34,   35,   36,   37,   38,   39,
	  40,   41,   42,   43,   44,   45};
int LLsymb;
static int LLreissue;
int yylex(void);
static int LLlexerWrapper(void) {
	if (LLreissue == -2 /* LL_NEW_TOKEN */) {
		return yylex();
	} else {
		int LLretval = LLreissue;
		LLreissue = -2 /* LL_NEW_TOKEN */;
		return LLretval;
	}
}
void LLmessage(int);
static void LLread(void) { LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]; }
static int LLskip(void) {
	int LL_i;
	if (LLcsymb >= 0) {
		if (LLtcnt[LLcsymb] != 0) return 0;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 0;
	}

	for (;;) {
		LLmessage(0 /* LL_DELETE */);
		while ((LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]) < 0) LLmessage(0 /* LL_DELETE */);
		if (LLtcnt[LLcsymb] != 0)
			return 1;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 1;
	}
}
static void LLerror(int LLtoken) {
	if (LLtoken == 256 /* EOFILE */) {
		LLmessage(-1 /* LL_MISSINGEOF */);
		while (LLindex[(LLsymb = LLlexerWrapper()) + 1] != 0) /*NOTHING*/ ;
		return;
	}
	LLtcnt[LLindex[LLtoken + 1]]++;
	LLskip();
	LLtcnt[LLindex[LLtoken + 1]]--;
	if (LLsymb != LLtoken) { LLreissue = LLsymb; LLmessage(LLtoken); }
}
#include "grammar.h"
#line 21 "grammar.g"

	#include <stdio.h>
	#include <stdlib.h>
	
	extern char * yytext; 	
	extern int lineNr;
	int solver_pid;

	void LLmessage(int token) {
		fprintf(stderr, "[PARSE ERROR] [line %d] unexpected token '%s'\n", lineNr, yytext);
		exit(EXIT_FAILURE);
	}
	
	char *copyToken() {
		int len = strlen(yytext);
		char *token = malloc(len+1);
		strcpy(token, yytext);
		return token;
	}
	
	void prnt(char *str) {
		fprintf(stdout, "%s", str);
	}
	
	void dimLoop(int *dimsizes, int dim, int maxdim, int printCnt, FILE *inp) {
		if(dim == maxdim || dim == maxdim-1) {
			int val;
			fprintf(stdout, "\t");
			for(int i = 0; i < printCnt; i++) {
				fscanf(inp, "%d", &val);
				fprintf(stdout, "%d ", val);
			}
			fprintf(stdout, "\n");
		} else {
			int dimsize = dimsizes[dim];
			for(int i = 0; i < dimsize; i++) {
				dimLoop(dimsizes, dim+1, maxdim, printCnt/dimsize, inp);
			}
		}
	}
	
	void printSolution(FILE *inp) {
		List variables = getAllVariables();
		while(variables != NULL) {
			Variable var = variables->item;
			fprintf(stdout, "%s = ", var->name);
			List dimsizes = var->dimsizes;
			int *dimsizes2 = safeMalloc(var->dims*sizeof(int));
			int cnt = 1;
			int dimsize;
			for(int i = 0; i < var->dims; i++) {
				dimsize = calcNumExp(dimsizes->item, NULL);
				dimsizes2[i] = dimsize;
				cnt *= dimsize;
				dimsizes = dimsizes->next;
			}
			dimLoop(dimsizes2, 0, var->dims, cnt, inp);
			variables = variables->next;
		}
	}
	
	void exitChild() {
		exit(0);
	}
	
	void waitForChild() {
		int returnStatus; 
		waitpid(solver_pid, &returnStatus, 0);
		if (returnStatus == 1) {
		   printf("The child process terminated with an error!.");
		}
	}
	
	int match(char *str1, char *str2) {
		return (strcmp(str1, str2) == 0);
	}
	
	void exitParent() {
		kill(solver_pid, SIGKILL);
		waitForChild();
		exit(0);
	}
	
	
	
	int main(int argc, char** argv) {
		FILE *solution_file;	

		createEmptyVarDB();
		currentIndex = 0;
		
		if(argc < 2) {
			fprintf(stderr, "[ERROR] No input file given\n"); 
			exit(-1);		
		}
		
		if(match(argv[1], "-h") || match(argv[1], "-help")) {
			printf("Usage: ./csp [OPTION]... [FILE]\n");
			printf("Solve the CSP problem defined in FILE using the given options.\n\n");
			printf("-h, -help    Display this help and exit.\n");
			printf("-iconst 1    Make the problem initially node-consistent.\n");
			printf("-iconst 2    Make the problem initially arc-consistent.\n");
			printf("-mrv         Use the heuristic Minimum Remaining Values (MRV).\n");
			printf("-deg         Use the degree heuristic.\n");
			printf("-arc         Keep the problem arc-consistent. Can not be combined with '-fc'\n");
			printf("-fc          Use Forward Checking. Can not be combined with '-arc'.\n");
			printf("\n");
			exit(0);
		}

		stdin = fopen(argv[argc-1], "r");	
		if(stdin == NULL) {
			fprintf(stderr, "[ERROR] Could not open %s\n", argv[argc-1]);
			exit(-1);
		}		
		stdout = fopen("translation.csp", "w");	
		
  		parser();
  		freopen("/dev/stdin", "r", stdin);
  		freopen("/dev/stdout", "w", stdout);
  		
  		solver_pid = fork();
		if(solver_pid == -1) {
		    fprintf (stderr, "[ERROR] Could not fork\n");
		    exit(EXIT_FAILURE);
		}
  		
  		if(solver_pid == 0) {		    
		    signal(SIGKILL, exitChild);
		    
		    argv[argc-1] = "translation.csp";
		    int error;
		    if( access("./solver", F_OK ) != -1 ) { // check if file exists
		    	argv[0] = "./solver";
		    	error = execvp("./solver", argv);
		    } else {
		    	argv[0] = "solver";
		    	error = execvp("solver", argv);
		    }
			fprintf(stderr, "[ERROR] Solver executed with errorcode %d.\n", error);
		} else {
			signal(SIGINT, exitParent);
			waitForChild();
			
			solution_file = fopen("solution.txt", "r");
			if(solution_file == NULL) {
				exit(-1);
			}
			int backtracking_points, solution_count;
		    
		    fscanf(solution_file, "%d", &backtracking_points);
		    fscanf(solution_file, "%d", &solution_count);
		    
		    for(int i = 0; i < solution_count; i++) {
		    	printf("### Solution %d ###\n", i+1);
		    	printSolution(solution_file);
		    	printf("\n");
		    }   
		    printf("Number of visited states: %d\n", backtracking_points);
		    printf("Number of solutions: %d\n\n", solution_count);
		    fclose(solution_file);
		    unlink("solution.txt");
		}
  		
  		
  		  		
        
	  	return 0;
	}


#line 306 "grammar.c"
static void LL0_problem(void);
static void LL1_body(void);
static void LL2_vars(void);
static void LL3_domains(void);
static void LL4_constraints(void);
static void LL5_solvespec(void);
static RecursiveType LL6_domainspec(void);
static RecursiveType LL7_constraintspec(void);
static ForAll LL8_forallspec(void);
static void LL9_datatype(void);
static List LL10_domain(void);
static Subdomain LL11_subdomain(void);
static int LL12_posint(void);
static Constraint LL13_constraint(void);
static NumExp LL14_numexp(void);
static Term LL15_term(void);
static Factor LL16_factor(void);
static Value LL17_value(void);
static List LL18_constraintlist(void);
static char * LL19_varname(void);
static NumExp LL20_indexspec(void);
static void LL21_vardef
#line 390 "grammar.g"
(int comma)
#line 331 "grammar.c"
;
static VarCall LL22_varcall(void);
static FunctionCall LL23_functioncall(void);
static List LL24_varlist(void);
static void LL25_vardeflist(void);
static void LL26_relop(void);
static void LL27_termop(void);
static void LL28_factorop(void);
static void LL0_problem(void){
LL1_body();
}
static void LL1_body(void){
LLscnt[0]++;
LLscnt[1]++;
LLscnt[2]++;
LL2_vars();
LLscnt[0]--;
LL3_domains();
LLscnt[1]--;
LL4_constraints();
LLscnt[2]--;
LL5_solvespec();
}
static void LL2_vars(void){
LLtcnt[17]++;
LLtcnt[28]++;
LL_SCANDONE(257);/* VARSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 201 "grammar.g"
{prnt("variables:\n");}
#line 364 "grammar.c"
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 2:/* DOMAINSTOK */
break;
case 28:/* VARNAME */
LLtcnt[17]++;
LLscnt[3]++;
LLtcnt[16]++;
LL25_vardeflist();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 204 "grammar.g"
{
						prnt(" : ");
					}
#line 385 "grammar.c"
LLread();
LLscnt[3]--;
LL9_datatype();
LLread();
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
#line 208 "grammar.g"
{
						prnt(";\n");
					}
#line 396 "grammar.c"
LLread();
continue;
}
LLtcnt[28]--;
break;
}
#line 212 "grammar.g"
{prnt("\n");}
#line 405 "grammar.c"
}
static void LL3_domains(void){
#line 240 "grammar.g"
RecursiveType
#line 410 "grammar.c"
domspec;
memset(&domspec, 0, sizeof(domspec));
{
LLtcnt[17]++;
LLscnt[4]++;
LL_SCANDONE(258);/* DOMAINSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 215 "grammar.g"
{prnt("domains:\n");}
#line 422 "grammar.c"
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 3:/* CONSTRAINTSTOK */
break;
case 28:/* VARNAME */
case 35:/* FORALLTOK */
domspec = LL6_domainspec();
#line 217 "grammar.g"
{
						rewriteDomainSpec(domspec, NULL);
					}
#line 439 "grammar.c"
LLread();
continue;
}
LLscnt[4]--;
break;
}
#line 221 "grammar.g"
{checkDomainsSet(); prnt("\n");}
#line 448 "grammar.c"
}
}
static void LL4_constraints(void){
#line 259 "grammar.g"
RecursiveType
#line 454 "grammar.c"
cspec;
memset(&cspec, 0, sizeof(cspec));
{
LLtcnt[17]++;
LLscnt[5]++;
LL_SCANDONE(259);/* CONSTRAINTSTOK */
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 224 "grammar.g"
{prnt("constraints:\n");}
#line 466 "grammar.c"
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 4:/* SOLVETOK */
break;
case 5:/* ALLTOK */
case 11:/* MINUSTOK */
case 26:/* PARENTOPEN */
case 28:/* VARNAME */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
case 35:/* FORALLTOK */
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
cspec = LL7_constraintspec();
#line 226 "grammar.g"
{
						rewriteConstraintSpec(cspec, NULL);
					}
#line 499 "grammar.c"
LLread();
continue;
}
LLscnt[5]--;
break;
}
#line 230 "grammar.g"
{prnt("\n");}
#line 508 "grammar.c"
}
}
static void LL5_solvespec(void){
#line 310 "grammar.g"
int
#line 514 "grammar.c"
posint;
memset(&posint, 0, sizeof(posint));
{
LLtcnt[17]++;
LLscnt[6]++;
LL_SCANDONE(260);/* SOLVETOK */
#line 234 "grammar.g"
{prnt(yytext);}
#line 523 "grammar.c"
LLread();
LLtcnt[17]--;
LL_SCANDONE(273);/* COLONTOK */
#line 235 "grammar.g"
{prnt(yytext);}
#line 529 "grammar.c"
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
LLscnt[6]--;
LL_SCANDONE(261);/* ALLTOK */
break;
case 29:/* DECTOK */
LLscnt[6]--;
posint = LL12_posint();
break;
}
#line 236 "grammar.g"
{prnt(yytext);}
#line 548 "grammar.c"
#line 237 "grammar.g"
{prnt("\n");}
#line 551 "grammar.c"
}
}
static RecursiveType LL6_domainspec(void){
#line 240 "grammar.g"
RecursiveType
#line 557 "grammar.c"
LLretval;
#line 289 "grammar.g"
List
#line 561 "grammar.c"
doms;
#line 457 "grammar.g"
List
#line 565 "grammar.c"
vars;
#line 277 "grammar.g"
ForAll
#line 569 "grammar.c"
fa;
#line 240 "grammar.g"
RecursiveType
#line 573 "grammar.c"
domspec;
memset(&LLretval, 0, sizeof(LLretval));
memset(&doms, 0, sizeof(doms));
memset(&vars, 0, sizeof(vars));
memset(&fa, 0, sizeof(fa));
memset(&domspec, 0, sizeof(domspec));
{
#line 240 "grammar.g"
Type type; void *data; List items = NULL;
#line 583 "grammar.c"
LLscnt[7]++;
LL_0:
switch (LLcsymb) {
case 35:/* FORALLTOK */
LLscnt[7]--;
LLscnt[4]++;
LLtcnt[38]++;
fa = LL8_forallspec();
LLread();
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 38:/* ENDTOK */
break;
case 28:/* VARNAME */
case 35:/* FORALLTOK */
domspec = LL6_domainspec();
#line 246 "grammar.g"
{items = addToListEnd(domspec, items);}
#line 606 "grammar.c"
LLread();
continue;
}
LLscnt[4]--;
break;
}
LLtcnt[38]--;
LL_SCANDONE(294);/* ENDTOK */
#line 248 "grammar.g"
{type = FORALL; fa->items = items; data = fa;}
#line 617 "grammar.c"
break;
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 28:/* VARNAME */
LLscnt[7]--;
LLtcnt[8]++;
LLscnt[8]++;
LLtcnt[16]++;
vars = LL24_varlist();
LLtcnt[8]--;
LL_SCANDONE(264);/* ARROWTOK */
LLread();
LLscnt[8]--;
doms = LL10_domain();
LLread();
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
#line 251 "grammar.g"
{
						type = DOMSET; 
						data = newDomainSet(vars, doms);
					}
#line 642 "grammar.c"
break;
}
#line 256 "grammar.g"
{LLretval = newRecursiveType(type, data);}
#line 647 "grammar.c"
}
return LLretval;
}
static RecursiveType LL7_constraintspec(void){
#line 259 "grammar.g"
RecursiveType
#line 654 "grammar.c"
LLretval;
#line 259 "grammar.g"
RecursiveType
#line 658 "grammar.c"
cspec;
#line 314 "grammar.g"
Constraint
#line 662 "grammar.c"
c;
#line 277 "grammar.g"
ForAll
#line 666 "grammar.c"
fa;
memset(&LLretval, 0, sizeof(LLretval));
memset(&cspec, 0, sizeof(cspec));
memset(&c, 0, sizeof(c));
memset(&fa, 0, sizeof(fa));
{
#line 259 "grammar.g"
Type type; void *data; List items = NULL;
#line 675 "grammar.c"
LLscnt[9]++;
LL_0:
switch (LLcsymb) {
case 35:/* FORALLTOK */
LLscnt[9]--;
LLscnt[5]++;
LLtcnt[38]++;
fa = LL8_forallspec();
LLread();
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 38:/* ENDTOK */
break;
case 5:/* ALLTOK */
case 11:/* MINUSTOK */
case 26:/* PARENTOPEN */
case 28:/* VARNAME */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
case 35:/* FORALLTOK */
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
cspec = LL7_constraintspec();
#line 264 "grammar.g"
{items = addToListEnd(cspec, items);}
#line 714 "grammar.c"
LLread();
continue;
}
LLscnt[5]--;
break;
}
LLtcnt[38]--;
LL_SCANDONE(294);/* ENDTOK */
#line 266 "grammar.g"
{type = FORALL; fa->items = items; data = fa;}
#line 725 "grammar.c"
break;
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
case 11:/* MINUSTOK */
case 26:/* PARENTOPEN */
case 28:/* VARNAME */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
LLscnt[9]--;
LLtcnt[16]++;
c = LL13_constraint();
LLtcnt[16]--;
LL_SCANDONE(272);/* SEMITOK */
#line 269 "grammar.g"
{
						type = CONSTRAINT;
						data = c;
					}
#line 758 "grammar.c"
break;
}
#line 274 "grammar.g"
{LLretval = newRecursiveType(type, data);}
#line 763 "grammar.c"
}
return LLretval;
}
static ForAll LL8_forallspec(void){
#line 277 "grammar.g"
ForAll
#line 770 "grammar.c"
LLretval;
#line 289 "grammar.g"
List
#line 774 "grammar.c"
values;
#line 382 "grammar.g"
char *
#line 778 "grammar.c"
name;
memset(&LLretval, 0, sizeof(LLretval));
memset(&values, 0, sizeof(values));
memset(&name, 0, sizeof(name));
{
LLtcnt[26]++;
LLtcnt[28]++;
LLtcnt[37]++;
LLscnt[8]++;
LLtcnt[27]++;
LL_SCANDONE(291);/* FORALLTOK */
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLtcnt[28]--;
name = LL19_varname();
LLread();
LLtcnt[37]--;
LL_SCANDONE(293);/* INTOK */
LLread();
LLscnt[8]--;
values = LL10_domain();
LLread();
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
#line 280 "grammar.g"
{LLretval = newForAll(name, values, NULL);}
#line 807 "grammar.c"
}
return LLretval;
}
static void LL9_datatype(void){
LLscnt[3]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 6:/* INTTYPE */
LLscnt[3]--;
LL_SCANDONE(262);/* INTTYPE */
break;
case 7:/* BOOLTYPE */
LLscnt[3]--;
LL_SCANDONE(263);/* BOOLTYPE */
break;
}
#line 285 "grammar.g"
{prnt(yytext);}
#line 830 "grammar.c"
}
static List LL10_domain(void){
#line 289 "grammar.g"
List
#line 835 "grammar.c"
LLretval;
#line 300 "grammar.g"
Subdomain
#line 839 "grammar.c"
dom;
memset(&LLretval, 0, sizeof(LLretval));
memset(&dom, 0, sizeof(dom));
{
#line 289 "grammar.g"
LLretval = NULL;
#line 846 "grammar.c"
LLscnt[10]++;
LLtcnt[15]++;
LLtcnt[10]++;
LL_SCANDONE(265);/* BRACKOPEN */
LLread();
LLscnt[10]--;
dom = LL11_subdomain();
#line 292 "grammar.g"
{LLretval = addToListEnd(dom, LLretval);}
#line 856 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 10:/* BRACKCLOSE */
break;
case 15:/* COMMATOK */
LLscnt[10]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[10]--;
dom = LL11_subdomain();
#line 295 "grammar.g"
{LLretval = addToListEnd(dom, LLretval);}
#line 873 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
LLtcnt[10]--;
LL_SCANDONE(266);/* BRACKCLOSE */
}
return LLretval;
}
static Subdomain LL11_subdomain(void){
#line 300 "grammar.g"
Subdomain
#line 887 "grammar.c"
LLretval;
#line 324 "grammar.g"
NumExp
#line 891 "grammar.c"
min;
#line 324 "grammar.g"
NumExp
#line 895 "grammar.c"
max;
memset(&LLretval, 0, sizeof(LLretval));
memset(&min, 0, sizeof(min));
memset(&max, 0, sizeof(max));
{
#line 300 "grammar.g"
NumExp min, max;
#line 903 "grammar.c"
LLtcnt[30]++;
min = LL14_numexp();
#line 302 "grammar.g"
{max = min;}
#line 908 "grammar.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[30]--;
break;
case 10:/* BRACKCLOSE */
case 15:/* COMMATOK */
LLtcnt[30]--;
break;
case 30:/* RANGETOK */
LLtcnt[30]--;
LLscnt[11]++;
LL_SCANDONE(286);/* RANGETOK */
LLread();
LLscnt[11]--;
max = LL14_numexp();
}
#line 307 "grammar.g"
{LLretval = newSubdomain(min, max);}
#line 929 "grammar.c"
}
return LLretval;
}
static int LL12_posint(void){
#line 310 "grammar.g"
int
#line 936 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_SCANDONE(285);/* DECTOK */
#line 311 "grammar.g"
{LLretval = atoi(yytext);}
#line 943 "grammar.c"
}
return LLretval;
}
static Constraint LL13_constraint(void){
#line 314 "grammar.g"
Constraint
#line 950 "grammar.c"
LLretval;
#line 324 "grammar.g"
NumExp
#line 954 "grammar.c"
exp1;
#line 324 "grammar.g"
NumExp
#line 958 "grammar.c"
exp2;
memset(&LLretval, 0, sizeof(LLretval));
memset(&exp1, 0, sizeof(exp1));
memset(&exp2, 0, sizeof(exp2));
{
#line 314 "grammar.g"
NumExp exp2 = NULL; NumExp exp1 = NULL; char *op = NULL;
#line 966 "grammar.c"
LLscnt[12]++;
exp1 = LL14_numexp();
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLscnt[12]--;
break;
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 27:/* PARENTCLOSE */
LLscnt[12]--;
break;
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
LLscnt[12]--;
LLscnt[12]++;
LLscnt[11]++;
LL26_relop();
#line 318 "grammar.g"
{op = copyToken();}
#line 992 "grammar.c"
LLread();
LLscnt[11]--;
exp2 = LL14_numexp();
}
#line 321 "grammar.g"
{LLretval = newConstraint(exp1, op, exp2);}
#line 999 "grammar.c"
}
return LLretval;
}
static NumExp LL14_numexp(void){
#line 324 "grammar.g"
NumExp
#line 1006 "grammar.c"
LLretval;
#line 334 "grammar.g"
Term
#line 1010 "grammar.c"
t;
memset(&LLretval, 0, sizeof(LLretval));
memset(&t, 0, sizeof(t));
{
#line 324 "grammar.g"
List termList = NULL; List opList = NULL;
#line 1017 "grammar.c"
LLscnt[13]++;
t = LL15_term();
#line 326 "grammar.g"
{termList = addToListEnd(t, termList);}
#line 1022 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 10:/* BRACKCLOSE */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 27:/* PARENTCLOSE */
case 30:/* RANGETOK */
break;
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
LLscnt[13]++;
LLscnt[14]++;
LL27_termop();
#line 328 "grammar.g"
{opList = addToListEnd(copyToken(), opList);}
#line 1048 "grammar.c"
LLread();
LLscnt[14]--;
t = LL15_term();
#line 329 "grammar.g"
{termList = addToListEnd(t, termList);}
#line 1054 "grammar.c"
continue;
}
LLscnt[13]--;
break;
}
#line 331 "grammar.g"
{LLretval = newNumExp(termList, opList);}
#line 1062 "grammar.c"
}
return LLretval;
}
static Term LL15_term(void){
#line 334 "grammar.g"
Term
#line 1069 "grammar.c"
LLretval;
#line 344 "grammar.g"
Factor
#line 1073 "grammar.c"
f;
memset(&LLretval, 0, sizeof(LLretval));
memset(&f, 0, sizeof(f));
{
#line 334 "grammar.g"
List factorList = NULL; List opList = NULL; 
#line 1080 "grammar.c"
LLscnt[15]++;
f = LL16_factor();
#line 336 "grammar.g"
{factorList = addToListEnd(f, factorList);}
#line 1085 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 10:/* BRACKCLOSE */
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 27:/* PARENTCLOSE */
case 30:/* RANGETOK */
break;
case 13:/* STARTOK */
case 24:/* MODTOK */
case 25:/* DIVTOK */
LLscnt[15]++;
LLscnt[16]++;
LL28_factorop();
#line 338 "grammar.g"
{opList = addToListEnd(copyToken(), opList);}
#line 1114 "grammar.c"
LLread();
LLscnt[16]--;
f = LL16_factor();
#line 339 "grammar.g"
{factorList = addToListEnd(f, factorList);}
#line 1120 "grammar.c"
continue;
}
LLscnt[15]--;
break;
}
#line 341 "grammar.g"
{LLretval = newTerm(factorList, opList);}
#line 1128 "grammar.c"
}
return LLretval;
}
static Factor LL16_factor(void){
#line 344 "grammar.g"
Factor
#line 1135 "grammar.c"
LLretval;
#line 344 "grammar.g"
Factor
#line 1139 "grammar.c"
f;
#line 355 "grammar.g"
Value
#line 1143 "grammar.c"
v;
memset(&LLretval, 0, sizeof(LLretval));
memset(&f, 0, sizeof(f));
memset(&v, 0, sizeof(v));
{
#line 344 "grammar.g"
Type ftype = -1; void *data;
#line 1151 "grammar.c"
LLscnt[16]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
case 26:/* PARENTOPEN */
case 28:/* VARNAME */
case 29:/* DECTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
LLscnt[16]--;
v = LL17_value();
#line 347 "grammar.g"
{ftype = VALUE; data = v;}
#line 1179 "grammar.c"
break;
case 11:/* MINUSTOK */
LLscnt[16]--;
LLscnt[16]++;
LL_SCANDONE(267);/* MINUSTOK */
LLread();
LLscnt[16]--;
f = LL16_factor();
#line 350 "grammar.g"
{ftype = NEGATION; data = f;}
#line 1190 "grammar.c"
break;
}
#line 352 "grammar.g"
{LLretval = newFactor(ftype, data);}
#line 1195 "grammar.c"
}
return LLretval;
}
static Value LL17_value(void){
#line 355 "grammar.g"
Value
#line 1202 "grammar.c"
LLretval;
#line 405 "grammar.g"
VarCall
#line 1206 "grammar.c"
vsc;
#line 324 "grammar.g"
NumExp
#line 1210 "grammar.c"
e;
#line 310 "grammar.g"
int
#line 1214 "grammar.c"
posint;
#line 344 "grammar.g"
Factor
#line 1218 "grammar.c"
powFactor;
#line 413 "grammar.g"
FunctionCall
#line 1222 "grammar.c"
fc;
memset(&LLretval, 0, sizeof(LLretval));
memset(&vsc, 0, sizeof(vsc));
memset(&e, 0, sizeof(e));
memset(&posint, 0, sizeof(posint));
memset(&powFactor, 0, sizeof(powFactor));
memset(&fc, 0, sizeof(fc));
{
#line 355 "grammar.g"
Type vtype = -1; int powtok = 0; Factor powFactor = NULL; void *data; 
#line 1233 "grammar.c"
LLscnt[17]++;
LLtcnt[14]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 29:/* DECTOK */
LLscnt[17]--;
posint = LL12_posint();
#line 358 "grammar.g"
{vtype = INT; data = copyToken();}
#line 1247 "grammar.c"
LLread();
break;
case 28:/* VARNAME */
LLscnt[17]--;
vsc = LL22_varcall();
#line 360 "grammar.g"
{vtype = VARSUBSTCALL; data = vsc;}
#line 1255 "grammar.c"
break;
case 5:/* ALLTOK */
case 31:/* MAXTOK */
case 32:/* MINTOK */
case 33:/* ABSTOK */
case 34:/* ANYTOK */
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
LLscnt[17]--;
fc = LL23_functioncall();
#line 362 "grammar.g"
{vtype = FUNCTIONCALL; data = fc;}
#line 1274 "grammar.c"
LLread();
break;
case 26:/* PARENTOPEN */
LLscnt[17]--;
LLscnt[11]++;
LLtcnt[27]++;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[11]--;
e = LL14_numexp();
#line 365 "grammar.g"
{vtype = NUMEXP; data = e;}
#line 1287 "grammar.c"
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
LLread();
break;
}
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[14]--;
break;
case 10:/* BRACKCLOSE */
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
case 13:/* STARTOK */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 24:/* MODTOK */
case 25:/* DIVTOK */
case 27:/* PARENTCLOSE */
case 30:/* RANGETOK */
LLtcnt[14]--;
break;
case 14:/* POWTOK */
LLtcnt[14]--;
LLscnt[16]++;
LL_SCANDONE(270);/* POWTOK */
#line 369 "grammar.g"
{powtok = 1;}
#line 1323 "grammar.c"
LLread();
LLscnt[16]--;
powFactor = LL16_factor();
}
#line 372 "grammar.g"
{LLretval = newValue(vtype, data, powtok, powFactor);}
#line 1330 "grammar.c"
}
return LLretval;
}
static List LL18_constraintlist(void){
#line 376 "grammar.g"
List
#line 1337 "grammar.c"
LLretval;
#line 314 "grammar.g"
Constraint
#line 1341 "grammar.c"
c;
#line 314 "grammar.g"
Constraint
#line 1345 "grammar.c"
c2;
memset(&LLretval, 0, sizeof(LLretval));
memset(&c, 0, sizeof(c));
memset(&c2, 0, sizeof(c2));
{
#line 376 "grammar.g"
LLretval = NULL;
#line 1353 "grammar.c"
LLtcnt[15]++;
c = LL13_constraint();
#line 378 "grammar.g"
{LLretval = addToListEnd(c, LLretval);}
#line 1358 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 27:/* PARENTCLOSE */
break;
case 15:/* COMMATOK */
LLscnt[18]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[18]--;
c2 = LL13_constraint();
#line 379 "grammar.g"
{LLretval = addToListEnd(c2, LLretval);}
#line 1375 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
}
return LLretval;
}
static char * LL19_varname(void){
#line 382 "grammar.g"
char *
#line 1387 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_SCANDONE(284);/* VARNAME */
#line 383 "grammar.g"
{LLretval = copyToken();}
#line 1394 "grammar.c"
}
return LLretval;
}
static NumExp LL20_indexspec(void){
#line 386 "grammar.g"
NumExp
#line 1401 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LLscnt[11]++;
LLtcnt[10]++;
LL_SCANDONE(265);/* BRACKOPEN */
LLread();
LLscnt[11]--;
LLretval = LL14_numexp();
LLtcnt[10]--;
LL_SCANDONE(266);/* BRACKCLOSE */
}
return LLretval;
}
static void LL21_vardef
#line 390 "grammar.g"
(int comma)
#line 1419 "grammar.c"
{
#line 386 "grammar.g"
NumExp
#line 1423 "grammar.c"
idx;
#line 382 "grammar.g"
char *
#line 1427 "grammar.c"
name;
memset(&idx, 0, sizeof(idx));
memset(&name, 0, sizeof(name));
{
#line 390 "grammar.g"
int dims = 0; List dimsizes = NULL;
#line 1434 "grammar.c"
LLtcnt[9]++;
name = LL19_varname();
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 15:/* COMMATOK */
case 17:/* COLONTOK */
break;
case 9:/* BRACKOPEN */
idx = LL20_indexspec();
#line 393 "grammar.g"
{
			dims++; 
			dimsizes = addToListEnd(idx, dimsizes);
		}
#line 1454 "grammar.c"
LLread();
continue;
}
LLtcnt[9]--;
break;
}
#line 398 "grammar.g"
{
		Variable var = newVariable(name, dims, dimsizes);
		addVarToDB(var);
		rewriteVarDef(var, comma);
	}
#line 1467 "grammar.c"
}
}
static VarCall LL22_varcall(void){
#line 405 "grammar.g"
VarCall
#line 1473 "grammar.c"
LLretval;
#line 289 "grammar.g"
List
#line 1477 "grammar.c"
dom;
#line 382 "grammar.g"
char *
#line 1481 "grammar.c"
name;
memset(&LLretval, 0, sizeof(LLretval));
memset(&dom, 0, sizeof(dom));
memset(&name, 0, sizeof(name));
{
#line 405 "grammar.g"
List indices = NULL; char *name;
#line 1489 "grammar.c"
LLtcnt[9]++;
name = LL19_varname();
LLread();
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 8:/* ARROWTOK */
case 10:/* BRACKCLOSE */
case 11:/* MINUSTOK */
case 12:/* PLUSTOK */
case 13:/* STARTOK */
case 14:/* POWTOK */
case 15:/* COMMATOK */
case 16:/* SEMITOK */
case 18:/* ISTOK */
case 19:/* SMALLERTOK */
case 20:/* GREATERTOK */
case 21:/* NEQTOK */
case 22:/* LEQTOK */
case 23:/* GEQTOK */
case 24:/* MODTOK */
case 25:/* DIVTOK */
case 27:/* PARENTCLOSE */
case 30:/* RANGETOK */
break;
case 9:/* BRACKOPEN */
dom = LL10_domain();
#line 408 "grammar.g"
{indices = addToListEnd(dom, indices); }
#line 1522 "grammar.c"
LLread();
continue;
}
LLtcnt[9]--;
break;
}
#line 410 "grammar.g"
{LLretval = newVarCall(name, indices);}
#line 1531 "grammar.c"
}
return LLretval;
}
static FunctionCall LL23_functioncall(void){
#line 413 "grammar.g"
FunctionCall
#line 1538 "grammar.c"
LLretval;
#line 324 "grammar.g"
NumExp
#line 1542 "grammar.c"
e;
#line 324 "grammar.g"
NumExp
#line 1546 "grammar.c"
exp1;
#line 324 "grammar.g"
NumExp
#line 1550 "grammar.c"
exp2;
#line 376 "grammar.g"
List
#line 1554 "grammar.c"
cl;
#line 405 "grammar.g"
VarCall
#line 1558 "grammar.c"
vc;
memset(&LLretval, 0, sizeof(LLretval));
memset(&e, 0, sizeof(e));
memset(&exp1, 0, sizeof(exp1));
memset(&exp2, 0, sizeof(exp2));
memset(&cl, 0, sizeof(cl));
memset(&vc, 0, sizeof(vc));
{
#line 413 "grammar.g"
char *funcName; Type type = -1; List argList = NULL;
#line 1569 "grammar.c"
LLscnt[19]++;
LL_0:
switch (LLcsymb) {
case 31:/* MAXTOK */
case 32:/* MINTOK */
LLscnt[19]--;
LLscnt[20]++;
LLtcnt[26]++;
LLscnt[11]++;
LLtcnt[15]++;
LLscnt[11]++;
LLtcnt[27]++;
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 31:/* MAXTOK */
LLscnt[20]--;
LL_SCANDONE(287);/* MAXTOK */
break;
case 32:/* MINTOK */
LLscnt[20]--;
LL_SCANDONE(288);/* MINTOK */
break;
}
#line 415 "grammar.g"
{funcName = copyToken(); type = MAXMIN;}
#line 1599 "grammar.c"
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[11]--;
exp1 = LL14_numexp();
#line 417 "grammar.g"
{argList = addToListEnd(exp1, argList);}
#line 1608 "grammar.c"
LLtcnt[15]--;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[11]--;
exp2 = LL14_numexp();
#line 419 "grammar.g"
{argList = addToListEnd(exp2, argList);}
#line 1616 "grammar.c"
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
break;
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
case 34:/* ANYTOK */
LLscnt[19]--;
LLscnt[21]++;
LLtcnt[26]++;
LLscnt[22]++;
LLtcnt[27]++;
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 5:/* ALLTOK */
LLscnt[21]--;
LL_SCANDONE(261);/* ALLTOK */
break;
case 34:/* ANYTOK */
LLscnt[21]--;
LL_SCANDONE(290);/* ANYTOK */
break;
}
#line 422 "grammar.g"
{funcName = copyToken(); type = ALLANY;}
#line 1648 "grammar.c"
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[22]--;
cl = LL18_constraintlist();
#line 424 "grammar.g"
{argList = cl;}
#line 1657 "grammar.c"
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
break;
case 33:/* ABSTOK */
LLscnt[19]--;
LLtcnt[26]++;
LLscnt[11]++;
LLtcnt[27]++;
LL_SCANDONE(289);/* ABSTOK */
#line 427 "grammar.g"
{funcName = copyToken(); type = ABS;}
#line 1669 "grammar.c"
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[11]--;
e = LL14_numexp();
#line 429 "grammar.g"
{argList = addToListEnd(e, argList);}
#line 1678 "grammar.c"
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
break;
case 36:/* ALLDIFFTOK */
case 39:/* SUMTOK */
case 40:/* PRODUCTTOK */
case 41:/* MAXIMUMTOK */
case 42:/* MINIMUMTOK */
case 43:/* EQUALTOK */
case 44:/* INCREASINGTOK */
case 45:/* DECREASINGTOK */
LLscnt[19]--;
LLscnt[23]++;
LLtcnt[26]++;
LLscnt[24]++;
LLtcnt[15]++;
LLtcnt[27]++;
LL_3:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 36:/* ALLDIFFTOK */
LLscnt[23]--;
LL_SCANDONE(292);/* ALLDIFFTOK */
#line 433 "grammar.g"
{funcName = copyToken(); type = ALLDIFF;}
#line 1707 "grammar.c"
break;
case 39:/* SUMTOK */
LLscnt[23]--;
LL_SCANDONE(295);/* SUMTOK */
#line 435 "grammar.g"
{funcName = copyToken(); type = SUM;}
#line 1714 "grammar.c"
break;
case 40:/* PRODUCTTOK */
LLscnt[23]--;
LL_SCANDONE(296);/* PRODUCTTOK */
#line 437 "grammar.g"
{funcName = copyToken(); type = PRODUCT;}
#line 1721 "grammar.c"
break;
case 41:/* MAXIMUMTOK */
LLscnt[23]--;
LL_SCANDONE(297);/* MAXIMUMTOK */
#line 439 "grammar.g"
{funcName = copyToken(); type = MAXIMUM;}
#line 1728 "grammar.c"
break;
case 42:/* MINIMUMTOK */
LLscnt[23]--;
LL_SCANDONE(298);/* MINIMUMTOK */
#line 441 "grammar.g"
{funcName = copyToken(); type = MINIMUM;}
#line 1735 "grammar.c"
break;
case 44:/* INCREASINGTOK */
LLscnt[23]--;
LL_SCANDONE(300);/* INCREASINGTOK */
#line 443 "grammar.g"
{funcName = copyToken(); type = INCREASING;}
#line 1742 "grammar.c"
break;
case 45:/* DECREASINGTOK */
LLscnt[23]--;
LL_SCANDONE(301);/* DECREASINGTOK */
#line 445 "grammar.g"
{funcName = copyToken(); type = DECREASING;}
#line 1749 "grammar.c"
break;
case 43:/* EQUALTOK */
LLscnt[23]--;
LL_SCANDONE(299);/* EQUALTOK */
#line 447 "grammar.g"
{funcName = copyToken(); type = EQUAL;}
#line 1756 "grammar.c"
break;
}
LLread();
LLtcnt[26]--;
LL_SCANDONE(282);/* PARENTOPEN */
LLread();
LLscnt[24]--;
vc = LL22_varcall();
#line 450 "grammar.g"
{argList = addToListEnd(vc, argList);}
#line 1767 "grammar.c"
for (;;) {
LL_4:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_4;
break;
case 27:/* PARENTCLOSE */
break;
case 15:/* COMMATOK */
LLscnt[24]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[24]--;
vc = LL22_varcall();
#line 451 "grammar.g"
{argList = addToListEnd(vc, argList);}
#line 1784 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
LLtcnt[27]--;
LL_SCANDONE(283);/* PARENTCLOSE */
break;
}
#line 454 "grammar.g"
{LLretval = newFunctionCall(type, funcName, argList);}
#line 1796 "grammar.c"
}
return LLretval;
}
static List LL24_varlist(void){
#line 457 "grammar.g"
List
#line 1803 "grammar.c"
LLretval;
#line 405 "grammar.g"
VarCall
#line 1807 "grammar.c"
vc;
memset(&LLretval, 0, sizeof(LLretval));
memset(&vc, 0, sizeof(vc));
{
#line 457 "grammar.g"
LLretval = NULL;
#line 1814 "grammar.c"
LLtcnt[15]++;
vc = LL22_varcall();
#line 459 "grammar.g"
{LLretval = addToListEnd(vc, LLretval);}
#line 1819 "grammar.c"
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 8:/* ARROWTOK */
break;
case 15:/* COMMATOK */
LLscnt[24]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[24]--;
vc = LL22_varcall();
#line 461 "grammar.g"
{LLretval = addToListEnd(vc, LLretval);}
#line 1836 "grammar.c"
continue;
}
LLtcnt[15]--;
break;
}
}
return LLretval;
}
static void LL25_vardeflist(void){
LLtcnt[15]++;
LL21_vardef
#line 465 "grammar.g"
(0)
#line 1850 "grammar.c"
;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 17:/* COLONTOK */
break;
case 15:/* COMMATOK */
LLscnt[24]++;
LL_SCANDONE(271);/* COMMATOK */
LLread();
LLscnt[24]--;
LL21_vardef
#line 465 "grammar.g"
(1)
#line 1868 "grammar.c"
;
continue;
}
LLtcnt[15]--;
break;
}
}
static void LL26_relop(void){
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 18:/* ISTOK */
LLscnt[12]--;
LL_SCANDONE(274);/* ISTOK */
break;
case 19:/* SMALLERTOK */
LLscnt[12]--;
LL_SCANDONE(275);/* SMALLERTOK */
break;
case 20:/* GREATERTOK */
LLscnt[12]--;
LL_SCANDONE(276);/* GREATERTOK */
break;
case 21:/* NEQTOK */
LLscnt[12]--;
LL_SCANDONE(277);/* NEQTOK */
break;
case 22:/* LEQTOK */
LLscnt[12]--;
LL_SCANDONE(278);/* LEQTOK */
break;
case 23:/* GEQTOK */
LLscnt[12]--;
LL_SCANDONE(279);/* GEQTOK */
break;
}
}
static void LL27_termop(void){
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 11:/* MINUSTOK */
LLscnt[13]--;
LL_SCANDONE(267);/* MINUSTOK */
break;
case 12:/* PLUSTOK */
LLscnt[13]--;
LL_SCANDONE(268);/* PLUSTOK */
break;
}
}
static void LL28_factorop(void){
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 13:/* STARTOK */
LLscnt[15]--;
LL_SCANDONE(269);/* STARTOK */
break;
case 24:/* MODTOK */
LLscnt[15]--;
LL_SCANDONE(280);/* MODTOK */
break;
case 25:/* DIVTOK */
LLscnt[15]--;
LL_SCANDONE(281);/* DIVTOK */
break;
}
}
void parser(void) {
	memset(LLscnt, 0, LL_NSETS * sizeof(int));
	memset(LLtcnt, 0, LL_NTERMINALS * sizeof(int));
	LLtcnt[0]++;
	LLsymb = 0;
	LLreissue = -2 /* LL_NEW_TOKEN */;
	LLread();
	LL0_problem();
	LLread();
	if (LLcsymb != 0) LLerror(256 /* EOFILE*/);
}

